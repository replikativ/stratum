(ns stratum.cached-storage
  "PSS-backed lazy storage for PersistentColumnIndex.

   Implements persistent-sorted-set's IStorage protocol with:
   - Konserve backend for durable persistence
   - LRU cache for frequently accessed nodes
   - Content-addressed (merkle) or random UUID addressing
   - Fressian serialization for PSS nodes and stratum domain types

   Following the datahike/proximum CachedStorage pattern."
  (:require [clojure.core.cache :as cache]
            [konserve.core :as k]
            [konserve.serializers :refer [fressian-serializer]]
            [hasch.core :as hasch]
            [stratum.chunk :as chunk]
            [stratum.stats :as stats])
  (:import [org.fressian.handlers WriteHandler ReadHandler]
           [org.replikativ.persistent_sorted_set
            IStorage Leaf Branch ANode Settings
            PersistentSortedSet RefType IMeasure]
           [stratum.chunk PersistentColChunk]
           [stratum.stats ChunkStats]
           [java.util List UUID]))

(set! *warn-on-reflection* true)

;; ============================================================================
;; Configuration
;; ============================================================================

(def ^:const BRANCHING_FACTOR
  "PSS branching factor. BF=64 gives ~4MB leaves (64 chunks x 64KB each),
   good granularity for partial loading at billion-row scale."
  64)

;; ============================================================================
;; ChunkEntry import (avoid circular dep by using the record directly)
;; ============================================================================

;; ChunkEntry is a defrecord from stratum.index with fields:
;;   chunk-id, chunk, stats
;; We reference it via its generated class.
(def ^:private chunk-entry-class
  (delay (Class/forName "stratum.index.ChunkEntry")))

(defn- chunk-entry?
  "Check if x is a ChunkEntry record."
  [x]
  (instance? @chunk-entry-class x))

(defn- make-chunk-entry
  "Create a ChunkEntry record from components."
  [chunk-id chunk stats]
  ;; Use the positional factory fn generated by defrecord
  (let [ctor (resolve 'stratum.index/->ChunkEntry)]
    (ctor chunk-id chunk stats)))

;; ============================================================================
;; Measure Ops (needed for Settings in deserialized PSS nodes)
;; ============================================================================

(defn- create-measure-ops
  "Create ChunkEntryMeasureOps instance for PSS Settings.
   Lazy to avoid circular dependency with stratum.index."
  ^IMeasure []
  (let [cls (Class/forName "stratum.index.ChunkEntryMeasureOps")]
    (.newInstance (.getConstructor cls (make-array Class 0))
                  (object-array 0))))

;; ============================================================================
;; Address Generation
;; ============================================================================

(defn- hashable-leaf-keys
  "Extract hashable representations from leaf keys (ChunkEntries).
   hasch can't hash PersistentColChunk directly, so we extract chunk-id + stats."
  [keys]
  (mapv (fn [entry]
          (if (chunk-entry? entry)
            [(:chunk-id entry)
             (let [s (:stats entry)]
               {:count (:count s) :sum (:sum s) :min-val (:min-val s) :max-val (:max-val s)})]
            entry))
        keys))

(defn gen-address
  "Generate UUID address for B-tree nodes.

   When crypto-hash? is true, computes content-based address (merkle tree):
   - Branch: hash of child addresses
   - Leaf: hash of chunk-ids + stats (not raw chunk data â€” hasch can't serialize ColChunks)
   When false, generates random UUID."
  [^ANode node crypto-hash?]
  (if crypto-hash?
    (if (instance? Branch node)
      (hasch/uuid (vec (.addresses ^Branch node)))
      (hasch/uuid (hashable-leaf-keys (.keys ^Leaf node))))
    (UUID/randomUUID)))

;; ============================================================================
;; CachedStorage Implementation
;; ============================================================================

(defrecord CachedStorage [store config cache stats pending-writes]
  IStorage
  (store [_this node]
    (swap! stats update :writes inc)
    (let [address (gen-address node (:crypto-hash? config))]
      (swap! pending-writes conj [address node])
      (swap! cache cache/miss address node)
      address))

  (accessed [_this address]
    (swap! stats update :accessed inc)
    (swap! cache cache/hit address)
    nil)

  (restore [_this address]
    (if-let [cached (cache/lookup @cache address)]
      (do
        (swap! cache cache/hit address)
        cached)
      (let [node (k/get store address nil {:sync? true})]
        (when (nil? node)
          (throw (ex-info "PSS node not found in storage"
                          {:address address
                           :crypto-hash? (:crypto-hash? config)})))
        (swap! stats update :reads inc)
        (swap! cache cache/miss address node)
        node))))

;; ============================================================================
;; Fressian Handlers
;; ============================================================================

(defn create-fressian-handlers
  "Create Fressian read/write handlers for PSS nodes and stratum domain types.

   The storage-atom resolves the circular reference: deserialized PersistentSortedSet
   nodes need their IStorage to lazy-load children, but the storage holds the store
   which holds the serializer which holds the handlers."
  [storage-atom]
  (let [measure-ops (create-measure-ops)
        settings (Settings. (int BRANCHING_FACTOR) RefType/WEAK measure-ops)]
    {:read-handlers
     {;; PSS top-level set
      "stratum.PersistentSortedSet"
      (reify ReadHandler
        (read [_ reader _tag _component-count]
          (let [{:keys [meta address count]} (.readObject reader)]
            (PersistentSortedSet. meta nil address @storage-atom nil (int count) settings 0))))

      ;; PSS Leaf node
      "stratum.PersistentSortedSet.Leaf"
      (reify ReadHandler
        (read [_ reader _tag _component-count]
          (let [{:keys [keys]} (.readObject reader)]
            (Leaf. ^List keys settings))))

      ;; PSS Branch node
      "stratum.PersistentSortedSet.Branch"
      (reify ReadHandler
        (read [_ reader _tag _component-count]
          (let [{:keys [keys level addresses]} (.readObject reader)]
            (Branch. (int level) ^List keys ^List (seq addresses) settings))))

      ;; ChunkEntry (defrecord from stratum.index)
      "stratum.ChunkEntry"
      (reify ReadHandler
        (read [_ reader _tag _component-count]
          (let [{:keys [chunk-id chunk-bytes chunk-stats]} (.readObject reader)
                chunk (chunk/chunk-from-bytes chunk-bytes)
                entry-stats (stats/->ChunkStats (:count chunk-stats)
                                                (:sum chunk-stats)
                                                (:sum-sq chunk-stats)
                                                (:min-val chunk-stats)
                                                (:max-val chunk-stats)
                                                (or (:null-count chunk-stats) 0))]
            (make-chunk-entry chunk-id chunk entry-stats))))

      ;; ChunkStats (defrecord from stratum.stats)
      "stratum.ChunkStats"
      (reify ReadHandler
        (read [_ reader _tag _component-count]
          (let [{:keys [count sum sum-sq min-val max-val null-count]} (.readObject reader)]
            (stats/->ChunkStats count sum sum-sq min-val max-val (or null-count 0)))))}

     :write-handlers
     {PersistentSortedSet
      {"stratum.PersistentSortedSet"
       (reify WriteHandler
         (write [_ writer pset]
           (when (nil? (.-_address ^PersistentSortedSet pset))
             (throw (ex-info "PSS must be stored before serialization" {:type :must-be-flushed})))
           (.writeTag writer "stratum.PersistentSortedSet" 1)
           (.writeObject writer {:meta (meta pset)
                                 :address (.-_address ^PersistentSortedSet pset)
                                 :count (count pset)})))}

      Leaf
      {"stratum.PersistentSortedSet.Leaf"
       (reify WriteHandler
         (write [_ writer leaf]
           (.writeTag writer "stratum.PersistentSortedSet.Leaf" 1)
           (.writeObject writer {:keys (vec (.keys ^Leaf leaf))})))}

      Branch
      {"stratum.PersistentSortedSet.Branch"
       (reify WriteHandler
         (write [_ writer node]
           (.writeTag writer "stratum.PersistentSortedSet.Branch" 1)
           (.writeObject writer {:level (.level ^Branch node)
                                 :keys (vec (.keys ^Branch node))
                                 :addresses (vec (.addresses ^Branch node))})))}}}))

(defn- chunk-entry-write-handler
  "Fressian write handler for ChunkEntry records.
   Serializes chunk data inline via chunk-to-bytes."
  []
  (reify WriteHandler
    (write [_ writer entry]
      (.writeTag writer "stratum.ChunkEntry" 1)
      (.writeObject writer {:chunk-id (:chunk-id entry)
                            :chunk-bytes (chunk/chunk-to-bytes (:chunk entry) (:stats entry))
                            :chunk-stats (let [s (:stats entry)]
                                           {:count (:count s)
                                            :sum (:sum s)
                                            :sum-sq (:sum-sq s)
                                            :min-val (:min-val s)
                                            :max-val (:max-val s)
                                            :null-count (:null-count s)})}))))

(defn- chunk-stats-write-handler
  "Fressian write handler for ChunkStats records."
  []
  (reify WriteHandler
    (write [_ writer stats]
      (.writeTag writer "stratum.ChunkStats" 1)
      (.writeObject writer {:count (:count stats)
                            :sum (:sum stats)
                            :sum-sq (:sum-sq stats)
                            :min-val (:min-val stats)
                            :max-val (:max-val stats)
                            :null-count (:null-count stats)}))))

;; ============================================================================
;; Factory Function
;; ============================================================================

(defn create-storage
  "Create CachedStorage backed by a konserve store.

   Args:
     store - Konserve store (filestore, memory, etc.)

   Options:
     :cache-size   - LRU cache size in nodes (default 1000)
     :crypto-hash? - Enable merkle tree addressing (default false)

   Returns: CachedStorage implementing IStorage."
  ([store] (create-storage store {}))
  ([store {:keys [cache-size crypto-hash?] :or {cache-size 1000 crypto-hash? false}}]
   (let [storage-atom (atom nil)
         handlers (create-fressian-handlers storage-atom)
         ;; Add ChunkEntry/ChunkStats write handlers (keyed by class, resolved lazily)
         chunk-entry-cls @chunk-entry-class
         all-write-handlers (assoc (:write-handlers handlers)
                                   chunk-entry-cls
                                   {"stratum.ChunkEntry" (chunk-entry-write-handler)}
                                   ChunkStats
                                   {"stratum.ChunkStats" (chunk-stats-write-handler)})
         config {:crypto-hash? crypto-hash?}
         store (assoc store
                      :serializers {:FressianSerializer
                                    (fressian-serializer
                                     (:read-handlers handlers)
                                     all-write-handlers)})
         storage (->CachedStorage
                  store
                  config
                  (atom (cache/lru-cache-factory {} :threshold cache-size))
                  (atom {:writes 0 :reads 0 :accessed 0})
                  (atom []))]
     (reset! storage-atom storage)
     storage)))

;; ============================================================================
;; Utilities
;; ============================================================================

(defn flush-writes!
  "Flush all pending writes to the underlying konserve store.
   Uses atomic removal pattern to avoid losing concurrent writes."
  [^CachedStorage storage]
  (let [store (.-store storage)
        pending @(.-pending-writes storage)]
    (when (seq pending)
      (doseq [[address node] pending]
        (k/assoc store address node {:sync? true}))
      ;; Atomic removal: drop only items we processed
      (swap! (.-pending-writes storage) #(vec (drop (count pending) %))))
    nil))

(defn storage-stats
  "Get storage statistics: {:writes N :reads N :accessed N}."
  [^CachedStorage storage]
  @(.-stats storage))

(defn pending-write-count
  "Return number of pending writes waiting to be flushed."
  [^CachedStorage storage]
  (count @(.-pending-writes storage)))

(defn clear-cache!
  "Clear the LRU cache. Nodes will be re-loaded from storage on next access."
  [^CachedStorage storage]
  (reset! (.-cache storage) (cache/lru-cache-factory {} :threshold 1000))
  nil)

(defn cache-size
  "Return number of nodes currently in cache."
  [^CachedStorage storage]
  (count @(.-cache storage)))
